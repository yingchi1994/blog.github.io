<!doctype html>
<html lang="en">
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

  <title>Kubernetes API Server 认证与授权机制 - Yingchi Blog</title>
  <meta content='Kubernetes API Server 认证与授权机制 - Yingchi Blog' property='title' />
  <meta content='Kubernetes API Server 认证与授权机制 - Yingchi Blog' property='og:title' />


<meta property="og:description" content="kube-apiserver 是 kubernetes 的网关性质的组件，是 kubernetes 集群资源操作的唯一入口，因此像认证与授权等一些过程很明显是要基于这个组件实施。kubernetes 集群的所有操作基本上都是通过 apiserver 这个组件进行的，它提供 HTTP RESTful 形式的 API 供集群内外客户端调用。kubernetes 对于访问 API 来说提供了三个步骤的安全措施：认证、授权、准入控制，当用户使用 kubectl，client-go 或者 REST API 请求 apiserver 时，都要经过这三个步骤的校验。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.yingchi.io/posts/2020/7/k8s-authn-authz.html" />


<meta property="article:published_time" content="2020-07-19T19:54:22&#43;08:00"/>

<meta property="article:modified_time" content="2020-07-19T19:54:22&#43;08:00"/>

<meta property="og:site_name" content="Yingchi&#39;s Blog" />







<meta name="generator" content="Hugo 0.71.1" />

<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" rel="stylesheet">
<style type="text/css">/*https://coolors.co/afd5aa-f0f2ef-a69f98-3d3d3d-8c6057*/
:root {
  --main-color: #8C6056; 
  --secondary-color: #AFD5AA;
  --logo-text-color: #fff;
  --body-text-color: #3d3d3d;
  --heading-text-color: #383838;
  --background-color: #fff;
}</style>
<link href='/css/tachyons.min.css' rel="stylesheet">
<link href='/css/styles.css' rel="stylesheet">


<link rel="icon" 

  href="/favicons/" 

type="image/x-icon"/>

<link href='/feed.xml' rel="alternate" type="application/atom+xml" title="Yingchi Blog" />
</head>
<body class="global-font">
  <nav class=" flex-ns justify-between border-box pa3 pl3-l pr2-l mt1 mt0-ns" id="navbar">
  <div class="flex">
    <a class="f4 fw4 ttu no-underline dim bg-main-color pv1 ph2 br2" id="site-title" href='/' title="Home">Yingchi Blog</a>
  </div>
  
  <div class=" flex-ns mt2 mt0-ns pv1">
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/' title="Home">Home</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/posts.html' title="Posts">Posts</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/tags.html' title="Tags">Tags</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/about.html' title="About">About</a>
    
  </div>
  
  
</nav>


<div 
id="scroll-navbar" 
class="scroll-navbar" 
style="color: #000; visibility: hidden; transition: opacity .5s, visibility .5s;" 
title="Test">
<div>
  <a 
  class="f5 fw4 ttu no-underline dim bg-main-color pv1 ph2 br2 mr3" 
  id="site-title" 
  href='https://blog.yingchi.io/'
  style="line-height: 40px;" 
  title="Home">Yingchi Blog</a>
</div>
<div style="line-height: 20px;" onclick="topFunction()">
  Kubernetes API Server 认证与授权机制
</div>
</div>


<style>
  .scroll-navbar {
    position: fixed;
    top: 0;
    width: 100%;
    background-color: #fff;
    color: #000;
    text-align: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  }
</style>
  
<main class="center mv4 content-width ph3">
  <div class="f3 fw6 heading-color heading-font post-title">Kubernetes API Server 认证与授权机制</div>
  <p class="silver f6 mt1 mb4 post-meta">
    <time>19 Jul 2020</time> 
     | 
    
    
    tags: [ <a href='/tags/kubernetes' class="link silver">kubernetes</a>  ]
    
  </p>
  <div class="lh-copy post-content"><p>kube-apiserver 是 kubernetes 的网关性质的组件，是 kubernetes 集群资源操作的唯一入口，因此像认证与授权等一些过程很明显是要基于这个组件实施。kubernetes 集群的所有操作基本上都是通过 apiserver 这个组件进行的，它提供 HTTP RESTful 形式的 API 供集群内外客户端调用。kubernetes 对于访问 API 来说提供了三个步骤的安全措施：认证、授权、准入控制，当用户使用 kubectl，client-go 或者 REST API 请求 apiserver 时，都要经过这三个步骤的校验。</p>
<p><img src="k8s-authn-authz/image-20200720200038316.png" alt="image-20200720200038316"></p>
<ul>
<li>认证解决的问题是<strong>识别用户的身份</strong>；</li>
<li>授权是<strong>明确用户具有哪些权限</strong>；</li>
<li>准入控制是<strong>作用于 kubernetes 中的资源对象</strong>。</li>
</ul>
<h2 id="kubernetes-api-server-认证机制authentication">Kubernetes API Server 认证机制（Authentication）</h2>
<p>一旦TLS连接建立，请求就进入到身份认证阶段，在这一阶段，请求有效负载由一个或多个认证器模块检查。</p>
<p>认证模块时管理员在集群创建过程中配置的，一个集群可能有多个认证模块配置，每个模块会依次尝试认证， 直到其中一个认证成功。</p>
<p>在主流的认证模块中会包括客户端证书、密码、plain tokens、bootstrap tokens以及JWT tokens（用于service account）。客户端证书的使用是默认的并且是最常见的方案。</p>
<p>kubernetes 目前所有的认证策略如下所示：</p>
<ul>
<li>X509 client certs</li>
<li>Static Token File</li>
<li>Bootstrap Tokens</li>
<li>Static Password File</li>
<li>Service Account Tokens</li>
<li>OpenId Connect Tokens</li>
<li>Webhook Token Authentication</li>
<li>Authticating Proxy</li>
<li>Anonymous requests</li>
<li>User impersonation</li>
<li>Client-go credential plugins</li>
</ul>
<h3 id="kubernetes-常用认证机制">Kubernetes 常用认证机制</h3>
<h4 id="x509-client-certs">X509 client certs</h4>
<p><strong>X509 client certs 认证方式是用在一些客户端访问 apiserver 以及集群组件之间访问时使用，比如 kubectl 请求 apiserver 时</strong>。</p>
<p>适用对象：<strong>外部用户</strong></p>
<p>X509是一种数字证书的格式标准，现在 HTTPS 依赖的 SSL 证书使用的就是使用的 X509 格式。X509 客户端证书认证方式是 kubernetes 所有认证中使用最多的一种，相对来说也是最安全的一种，kubernetes 的一些部署工具 kubeadm、minkube 等都是基于证书的认证方式。客户端证书认证叫作 TLS 双向认证，也就是服务器客户端互相验证证书的正确性，在都正确的情况下协调通信加密方案。目前最常用的 X509 证书制作工具有 openssl、cfssl 等。</p>
<h4 id="service-account-tokens">Service Account Tokens</h4>
<p><strong>serviceaccounts 是用在 pod 中访问 apiserver 时进行认证的，比如使用自定义 controller 时</strong>。</p>
<p>适用对象：<strong>内部用户</strong></p>
<p>有些情况下，我们希望在 pod 内部访问 apiserver，获取集群的信息，甚至对集群进行改动。针对这种情况，kubernetes 提供了一种特殊的认证方式：serviceaccounts。</p>
<p>serviceaccounts 是面向 namespace 的，每个 namespace 创建的时候，kubernetes 会自动在这个 namespace 下面创建一个默认的 serviceaccounts；并且这个 serviceaccounts 只能访问该 namespace 的资源。</p>
<p>serviceaccounts 和 pod、service、deployment 一样是 kubernetes 集群中的一种资源，用户也可以创建自己的 serviceaccounts。</p>
<p>serviceaccounts 主要包含了三个内容：namespace、token 和 ca，每个 serviceaccounts 中都对应一个 secrets，namespace、token 和 ca 信息都是保存在 secrets 中且都通过 base64 编码的。namespace 指定了 pod 所在的 namespace，ca 用于验证 apiserver 的证书，token 用作身份验证，它们都通过 mount 的方式保存在 pod 的文件系统中，其三者都是保存在 <code>/var/run/secrets/kubernetes.io/serviceaccount/</code>目录下。</p>
<h2 id="kubernetes-api-server-授权机制authorization">Kubernetes API Server 授权机制（Authorization）</h2>
<p>请求经过认证之后，下一步就是确认这一操作是否被允许执行，即<strong>授权</strong>。</p>
<p>对于授权一个请求，Kubernetes主要关注三个方面：</p>
<ul>
<li><strong>请求者的用户名</strong></li>
<li><strong>请求动作</strong></li>
<li><strong>动作影响的对象</strong></li>
</ul>
<p>用户名从嵌入 token 的头部中提取，动作是映射到CRUD操作的HTTP动词之一（如 GET、POST、PUT、DELETE），对象是其中一个有效的 Kubernetes 资源对象。</p>
<p>Kubernetes基于一个存在策略来决定授权。默认情况下，Kubernetes遵循封闭开放的理念，这意味着需要一个明确的允许策略才可以访问资源。</p>
<p>与身份认证类似，授权也是基于一个或多个模块配置的，如ABAC模式、RBAC模式以及Webhook模式。当管理员创建集群时，他们配置与API sever集成的授权模块。如果多个模块都在使用，Kubernetes会检查每个模块并且如果其中任一模块授权了请求，则请求授权通过。如果所有模块全部拒绝请求，则请求被拒绝（HTTP状态码403）。</p>
<p>kubernetes 目前支持如下四种授权机制：</p>
<ul>
<li>Node</li>
<li>ABAC</li>
<li>RBAC</li>
<li>Webhook</li>
</ul>
<h3 id="kubernetes-常用授权机制">kubernetes 常用授权机制</h3>
<h4 id="rbac基于角色的访问控制">RBAC（基于角色的访问控制）</h4>
<p>RBAC，Role-Based Access Control，即<strong>基于角色的访问控制</strong>，通过自定义角色并将角色和特定的 user，group，serviceaccounts 关联起来已达到权限控制的目的。</p>
<p>RBAC 中有三个比较重要的概念：</p>
<ul>
<li><strong>Role</strong>：角色，它其实是<strong>一组规则</strong>，定义了一组对 Kubernetes API 对象的操作权限；</li>
<li><strong>Subject</strong>：被作用者，包括 <strong>user</strong>，<strong>group</strong>，<strong>serviceaccounts</strong>，通俗来讲就是<strong>认证机制中所识别的用户</strong>；</li>
<li><strong>RoleBinding</strong>：定义了“<strong>Role</strong>”和“<strong>Subject</strong>”的绑定关系，也就是将用户以及操作权限进行绑定；</li>
</ul>
<p>RBAC 其实就是通过创建角色(Role），通过 RoleBinding 将被作用者（subject）和角色（Role）进行绑定。下图是 RBAC 中的几种绑定关系：</p>
<p><img src="k8s-authn-authz/v2-cfb5b4d8297a977424ffa76d7591c958_1440w.jpg" alt="img"></p>
<h2 id="准入控制admission-control">准入控制(Admission Control)</h2>
<p>准入控制是请求的最后一个步骤，准入控制有许多内置的模块，可以作用于对象的 &ldquo;CREATE&rdquo;、&ldquo;UPDATE&rdquo;、&ldquo;DELETE&rdquo;、&ldquo;CONNECT&rdquo; 四个阶段。在这一过程中，如果任一准入控制模块拒绝，那么请求立刻被拒绝。一旦请求通过所有的准入控制器后就会写入对象存储中。</p>
<p>服务网格 Istio 技术的 Sidecar 注入过程就是依赖于 Kubernetes 的准入控制实现的。</p>
<p>Admission Controller 是拦截 API Server 请求 (经过身份验证的) 的网关，并且可以修改请求对象或拒绝请求。简而言之，它可以认为是拦截器，类似 web 框架中的 middleware，是 Kubernetes API Server 用于拦截请求的一种手段。</p>
<p>Kubernetes 为什么引入 admission 这种机制？</p>
<ol>
<li>虽然 Kubernetes 有 Authentication &amp; Authorization 这种认证授权机制，Authentication &amp; Authorization 运行在 filter 中，<strong>只能获取 http 请求 header 以及证书，并不能获取请求的 body</strong>。所以不可以对请求的对象进行任何操作，因为获取不到对象。</li>
<li>Admission Controller 运行在 API Server 的增删改查 handler 中，可以自然地操作 API resource。</li>
</ol>
<p>API Server 接收到客户端请求后首先进行认证授权，认证授权通过后才会进行后续的 endpoint handler 处理，kube-apiserver 处理资源请求的流程如下：</p>
<p><img src="k8s-authn-authz/193130833bb01379855014eda1e9cadd.png" alt="图片.png"></p>
<p>可以看到，在 Authentication &amp; Authorization 之后请求就交由 Admission Controller 继续处理，这里涉及到 Admission 两个重要阶段，<code>Mutating</code>和<code>Validating</code>，它们的区别如下：</p>
<ul>
<li>Mutating：可以对请求内容进行修改；</li>
<li>Validating：不允许修改请求内容，但可以根据请求的内容判断是继续执行该请求还是拒绝该请求；</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/Dev0ps/p/10852445.html">https://www.cnblogs.com/Dev0ps/p/10852445.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/111245097">https://zhuanlan.zhihu.com/p/111245097</a></li>
</ul></div>
</main>
 






<div class="tl fixed list-pages lh-copy" id="contents-list"></div>



<div class="pagination tc tr-l db fixed-l bottom-2-l right-2-l mb3 mb0-l">
  
<a id="scroll-to-top" class="f6 o-0 link br2 ph2 pv1 mb1 bg-main-color pointer" onclick="topFunction()" style="color: #fff; visibility: hidden; display: none; transition: opacity .5s, visibility .5s;" title="back to top">back to top</a>
<br>
  <p class="mb0 mt2">
  <a href="https://blog.yingchi.io/posts/2020/6/cka-note.html">prev post</a>
  <a href="https://blog.yingchi.io/posts/2020/7/k8s-rbac.html">next post</a>
  </p>
</div>

  <footer class="content-width mt0 mt5-l mb4 f6 center ph4 gray tc tl-l">
  <hr class="dn db-l ml0-l gray w3"><br>
  Powered by <a href="https://gohugo.io/" target="_blank" class="link gray dim">Hugo</a>, based on the <a href="https://github.com/lingxz/er" target="_blank" class="link gray dim">Er</a> theme. <br>
  © 2021 Joey.Jiang
</footer>
  



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<style>.is-active-link::before { background-color: var(--secondary-color); }</style>




<script type="text/javascript">
var prevScrollpos = window.pageYOffset;
window.onscroll = function() {
  var currentScrollPos = window.pageYOffset;

  
  if (document.getElementById("tag-cloud") !== null) { 
    if (prevScrollpos > currentScrollPos) { 
      document.getElementById("tag-cloud").style.visibility = "visible";
      document.getElementById("tag-cloud").style.opacity = "1";
    } else {
      document.getElementById("tag-cloud").style.visibility = "hidden";
      document.getElementById("tag-cloud").style.opacity = "0";
    }
  }
  


  
  if (document.body.scrollTop > 500 || document.documentElement.scrollTop > 500) {
      document.getElementById("scroll-to-top").style.display = "inline";
      document.getElementById("scroll-to-top").style.visibility = "visible";
      document.getElementById("scroll-to-top").style.opacity = "1";
  } else {
      document.getElementById("scroll-to-top").style.visibility = "hidden";
      document.getElementById("scroll-to-top").style.opacity = "0";
  }
  

  
  if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
      document.getElementById("scroll-navbar").style.display = "inline";
      document.getElementById("scroll-navbar").style.visibility = "visible";
      document.getElementById("scroll-navbar").style.opacity = "1";
  } else {
      document.getElementById("scroll-navbar").style.visibility = "hidden";
      document.getElementById("scroll-navbar").style.opacity = "0";
  }

  prevScrollpos = currentScrollPos;

}



function topFunction() {
  document.body.scrollTop = 0; 
  document.documentElement.scrollTop = 0; 
}













if (document.getElementById("contents-list") !== null && document.getElementsByClassName("post-content").length !== 0) { 
  tocbot.init({
    
    tocSelector: '#contents-list',
    
    contentSelector: '.post-content',
    
    headingSelector: 'h1, h2, h3',
  });
}


</script>




</body>
</html>