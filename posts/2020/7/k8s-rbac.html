<!DOCTYPE html>
<html lang="en" data-theme=""><head>
    <title> Joey Jiang | 一文读懂 Kubernetes RBAC 机制 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.71.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Infrastructure SRE / Golang / Python">
    
    <link rel="stylesheet"
          href="https://blog.yingchi.io/css/style.min.8a9cc11a1afa7bd869914c587182281a374d06d6c3e09e330e86cfccf4908668.css"
          integrity="sha256-ipzBGhr6e9hpkUxYcYIoGjdNBtbD4J4zDobPzPSQhmg="
          crossorigin="anonymous"
          type="text/css">
    
    <link rel="stylesheet"
        href="https://blog.yingchi.io/css/markupHighlight.min.9755453ffb7bc4cd220f86ebb5922107b49f193cc62fc17e9785d27b33a8bf5b.css"
        integrity="sha256-l1VFP/t7xM0iD4brtZIhB7SfGTzGL8F&#43;l4XSezOov1s="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="https://blog.yingchi.io/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://blog.yingchi.io/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://blog.yingchi.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://blog.yingchi.io/favicons/favicon-16x16.png">

    <link rel="canonical" href="https://blog.yingchi.io/posts/2020/7/k8s-rbac.html">

    
    
    
    
    <script type="text/javascript"
            src="https://blog.yingchi.io/js/anatole-header.min.d8599ee07b7d3f11bafbac30657ccc591e8d7fd36a9f580cd4c09e24e0e4a971.js"
            integrity="sha256-2Fme4Ht9PxG6&#43;6wwZXzMWR6Nf9Nqn1gM1MCeJODkqXE="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="https://blog.yingchi.io/js/anatole-theme-switcher.min.e289e9ebb2a4e7a7f895859c8a2b0da2de1ec73f22cea58d8475aa0597023837.js"
                integrity="sha256-4onp67Kk56f4lYWciisNot4exz8izqWNhHWqBZcCODc="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.yingchi.io/images/site-feature-image.png"/>

<meta name="twitter:title" content="一文读懂 Kubernetes RBAC 机制"/>
<meta name="twitter:description" content="之前在做 PaaS 平台开发时涉及到租户的权限管理，考虑到 Kubernetes 默认提供了 RBAC（基于角色的访问控制）机制，于是想如何利用好 Kubernetes 的 RBAC 来实现。但是开始学习这块儿知识的时候还是遇到了一些问题，比如 Role 和 ClusterRole，Role Binding 和 ClusterRoleBinding，很多概念是比较模糊的，随着后来深入的学习了解和实践才算理清它们之间的关系，这篇文章就是分享一下这期间学到的内容。"/>

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="https://blog.yingchi.io/images/profile.jpg" alt="profile picture">
            <h2 title=""><a href="/">Yingchi&#39;s Blog</a></h2>
            <div class="description">
                <p>Infrastructure SRE / Golang / Python</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://yingchi.io" rel="me" aria-label="Home">
                    <i class="fa fa-home" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/yingchi1994" rel="me" aria-label="GitHub">
                    <i class="fab fa-github" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:yingchi1994@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="tag-area">
        
<ul>
  <li class="tag-list">
    
    <a href="/tags/cloud-native.html">
      <span>
        <span class="tag-yingchi">
          Cloud Native
          [<span style="color:rgb(255, 223, 79);">1</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/docker.html">
      <span>
        <span class="tag-yingchi">
          Docker
          [<span style="color:rgb(255, 223, 79);">2</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/golang.html">
      <span>
        <span class="tag-yingchi">
          Golang
          [<span style="color:rgb(255, 223, 79);">5</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/istio.html">
      <span>
        <span class="tag-yingchi">
          Istio
          [<span style="color:rgb(255, 223, 79);">2</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/kubernetes.html">
      <span>
        <span class="tag-yingchi">
          Kubernetes
          [<span style="color:rgb(255, 223, 79);">15</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/network.html">
      <span>
        <span class="tag-yingchi">
          Network
          [<span style="color:rgb(255, 223, 79);">4</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/note.html">
      <span>
        <span class="tag-yingchi">
          Note
          [<span style="color:rgb(255, 223, 79);">1</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/service-mesh.html">
      <span>
        <span class="tag-yingchi">
          Service Mesh
          [<span style="color:rgb(255, 223, 79);">2</span>]
        </span>
      </span>
    </a>
  </li>
</ul>

</div>




    <div class="footer">
        <div class="by_farbox">&copy; Joey Jiang  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/posts.html"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/tags.html"
                        
                   title="">Tags</a></li>
        
            
            <li><a 
                   href="/about.html"
                        
                   title="">About</a></li>
        
        
        
            <li class="theme-switch-item">
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            <div class="post-title">
                <h3>一文读懂 Kubernetes RBAC 机制</h3>
                
            </div>

            <p>之前在做 PaaS 平台开发时涉及到租户的权限管理，考虑到 Kubernetes 默认提供了 RBAC（基于角色的访问控制）机制，于是想如何利用好 Kubernetes 的 RBAC 来实现。但是开始学习这块儿知识的时候还是遇到了一些问题，比如 Role 和 ClusterRole，Role Binding 和 ClusterRoleBinding，很多概念是比较模糊的，随着后来深入的学习了解和实践才算理清它们之间的关系，这篇文章就是分享一下这期间学到的内容。</p>
<h2 id="什么是-rbac">什么是 RBAC？</h2>
<h3 id="rbac基于角色的访问控制">RBAC（基于角色的访问控制）</h3>
<p>RBAC，Role-Based Access Control，即<strong>基于角色的访问控制</strong>，通过自定义具有某些特定 Permission 的 Role，然后将 Role 和特定的 Subject（user，group，serviceaccounts&hellip;)关联起来已达到权限控制的目的。</p>
<p>RBAC 中有三个比较重要的概念：</p>
<ul>
<li><strong>Role</strong>：角色，本质是<strong>一组规则权限的集合</strong>，注意：RBAC 中，Role 只声明授予权限，而不存在否定规则；</li>
<li><strong>Subject</strong>：被作用者，包括 <strong>user</strong>，<strong>group</strong>，通俗来讲就是<strong>认证机制中所识别的用户</strong>；</li>
<li><strong>RoleBinding</strong>：定义了“<strong>Role</strong>”和“<strong>Subject</strong>”的绑定关系，也就是将用户以及操作权限进行绑定；</li>
</ul>
<p>RBAC 其实就是通过创建角色(Role），通过 RoleBinding 将被作用者（subject）和角色（Role）进行绑定。下图是 RBAC 中的几种绑定关系：</p>
<p><img src="k8s-rbac/image-20200724134525120.png" alt="image-20200724134525120"></p>
<h2 id="kubernetes-rbac">Kubernetes RBAC</h2>
<p>现在以 Kubernetes 的视角重新来看 RBAC 的实现。</p>
<p>Kubernetes 中实现 RBAC 角色创建、角色绑定整个流程还是比较清晰的，RBAC 的配置都是以资源配置的形式呈现给管理员，我们只需要定义一些配置文件即可，当然在这其中会涉及到对一些配置的理解。首先来看 Kubernetes 中 RBAC 配置关系图：</p>
<p><img src="k8s-rbac/image-20200724142728798.png" alt="image-20200724142728798"></p>
<p>如图可知，实现 Kubernetes 的自定义 RBAC 过程，主要涉及到几个概念，其实一开始已经提到过了，这不过在 Kubernetes 中定义了更具体的概念，这是重点需要关注的。</p>
<h3 id="subject">Subject</h3>
<p>主体，kubernetes 中的 Subject 包括了 User、Group、Service Account，前两个好理解，Service Account 其实就是区别开 User Account 的，Kubernetes 中的资源也是可以当做一个 Subject 的，比如一个 Pod 需要操作集群资源时，它采用的就是 Service Account。</p>
<p>Kubernetes 并没有实现对于 User Account 的直接管理，需要管理员自行手动创建 User Account，本文不针对这一块儿展开说明，大家可以查阅相关文章进行学习。</p>
<h3 id="role">Role</h3>
<p>角色，角色本质就是一组规则权限的集合，通过与具体的 Subject 绑定，从而赋予 Subject 相应的一组权限。</p>
<p>在 Kubernetes 中，Role 分为两类：</p>
<ul>
<li>Role：角色，可以理解为 Namespace Role，Role 在定义时要指定 Namespace，即这个 Role 是定义在 Namespace 内部，因此它所定义的规则权限集合也是针对于其定义所在的 Namespace 下的资源。</li>
<li>ClusterRole：集群角色，顾名思义，这种类型的 Role 是定义在整个 Cluster 下的，定义 Cluster Role 时不需要指定具体的 Namespace。</li>
</ul>
<p><strong>Role 示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: Role
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">namespace</span>: ns-a  <span style="color:#75715e"># 定义于 namespace 下</span>
  <span style="color:#66d9ef">name</span>: pod-reader
<span style="color:#66d9ef">rules</span>:
- <span style="color:#66d9ef">apiGroups</span>: [<span style="color:#e6db74">&#34;&#34;</span>]
  <span style="color:#66d9ef">resources</span>: [<span style="color:#e6db74">&#34;pods&#34;</span>]
  <span style="color:#66d9ef">verbs</span>: [<span style="color:#e6db74">&#34;get&#34;</span>, <span style="color:#e6db74">&#34;watch&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span>]
</code></pre></div><p><strong>ClusterRole 示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: ClusterRole
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pod-reader
<span style="color:#66d9ef">rules</span>:
- <span style="color:#66d9ef">apiGroups</span>: [<span style="color:#e6db74">&#34;&#34;</span>]
  <span style="color:#66d9ef">resources</span>: [<span style="color:#e6db74">&#34;pods&#34;</span>]
  <span style="color:#66d9ef">verbs</span>: [<span style="color:#e6db74">&#34;get&#34;</span>, <span style="color:#e6db74">&#34;watch&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span>]
</code></pre></div><p>注意：ClusterRole 并不代表权限控制的范围是整个 Cluster，还与之后要讲的 Binding 类型有关系，这里的 ClusterRole 应该理解为一种全局量，可以作用于某个 Namespace 下（起到复用的作用），可以作用于 Cluster 范围下。</p>
<p>每个 Role 在定义时关键的一步要指定该 Role 所具有的 rules，Kubernetes 中权限规则需要指定以下几点：</p>
<ul>
<li>apiGroups：资源组，<code>&quot;&quot;</code> 缺省为 core 组资源，其它诸如 apps 等；</li>
<li>resources：资源，比如 pods、deployments、services、secrets 等；</li>
<li>verbs：操作动词，如 get、list、watch、create、delete、update 等。</li>
</ul>
<h3 id="binding">Binding</h3>
<p>绑定，单从概念上很好理解，就是把定义好规则权限的 Role 绑定到指定的 Subject 上，从而赋予 Subject 相应的一系列权限。</p>
<p>kubernetes 中 Binding 分为两种：</p>
<ul>
<li>RoleBinding：绑定 Role/ClusterRole 到 Subject，生效于具体的 Namespace 范围资源；</li>
<li>ClusterRoleBinding：绑定 ClusterRole 到 Subject，生效于 Cluster 范围资源；</li>
</ul>
<p>再次强调：</p>
<p><strong>Kubernetes 中权限控制的范围（Namespace/Cluster）是由 Binding 的类型决定的，而不是根据 Role 和 ClusterRole 决定的，这一点一定要记住</strong>。</p>
<h3 id="作用于-namespace-范围的-rbac-方案分析">作用于 Namespace 范围的 RBAC 方案分析</h3>
<h4 id="方法1role--rolebinding-的组合">方法1：Role + RoleBinding 的组合</h4>
<p><img src="k8s-rbac/image-20200724152635068.png" alt="image-20200724152635068"></p>
<p>如上图，这种方式是比较直观的，因为之前说过 Kubernetes 中的 Role 应该理解为 Namespace Role，它是定义在 Namespace 下面的，因此如果要实现 Namespace 范围内的 Subject 与 Role 的绑定，无非就是通过配置一个 RoleBinding 把两者联系起来。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: RoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pods-reader-binding
  <span style="color:#66d9ef">namespace</span>: ns-a
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: Role
  <span style="color:#66d9ef">name</span>: pod-reader
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h4 id="方法2clusterrole--rolebinding-的组合推荐">方法2：ClusterRole + RoleBinding 的组合（推荐）</h4>
<p><img src="k8s-rbac/image-20200724153218582.png" alt="image-20200724153218582"></p>
<p>一听 ClusterRole，很多朋友会潜意识认为是关于集群范围下的权限控制，但是实际上，权限控制的范围和 Role 的类型没有直接的关系，ClusterRole，它的本质是一个定义在全局的角色，可以作用于 Namespace 下，可以被多个 Namespace 复用，也可以作用于 Cluster 下。</p>
<p>我们现在需要实现 Namespace 范围内绑定 Subject &amp; Role，就是将 ClusterRole 的权限范围控制在 Namespace 层面，因此采用 RoleBinding 将 Subject 与 ClusterRole 即可实现。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: RoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pods-reader-binding
  <span style="color:#66d9ef">namespace</span>: ns-a
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: ClusterRole
  <span style="color:#66d9ef">name</span>: pod-reader
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h4 id="方法分析">方法分析</h4>
<p>为什么会推荐使用 ClusterRole + RoleBinding 的组合呢？</p>
<p>思考一个问题，假如设计一个 PodReader Role，作用就是有 get/list/watch 当前 Namespace 下 Pod 的权限，如果两个 namespace 都需要这么一个 Role，那么应该怎么设计呢？</p>
<p>采用上面讲的第一种方法的话，每个 namespace 需要定义一个 PodReader 的 Role：</p>
<p><img src="k8s-rbac/image-20200724160240848.png" alt="image-20200724160240848"></p>
<p>这样做有个很明显的缺点，PodReader 的规则权限其实在每个 Namespace 下都是一样的，但是由于 Role 的限制，必须在每个 Namespace 下单独定义，资源浪费，过程也不优雅，如何去复用 PodReader 这个 Role 呢？于是，才有了第二种方法：</p>
<p><img src="k8s-rbac/image-20200724160150128.png" alt="image-20200724160150128"></p>
<p>如图，也就是将 PodReader 定义为 ClusterRole，然后通过 RoleBinding 在不同 Namespace 下绑定不同的 Subject 到同一个 ClusterRole。</p>
<h4 id="小结">小结</h4>
<p>如果自定义的 Role 在很多个 Namespace 中都会用到，那么推荐采用 ClusterRole + RoleBinding 的组合，实现 Role 的复用，如果真的是某个 Namespace 必须要单独定义的私有 Role，再去用 Role + RoleBinding 的组合，但是这样的话 Role 就会比较局限。</p>
<h3 id="作用于集群范围的-rbac-方案分析">作用于集群范围的 RBAC 方案分析</h3>
<p>方案只有一个，就是通过 <strong>ClusterRoleBinding + ClusterRole</strong>：</p>
<p><img src="k8s-rbac/image-20200724161347135.png" alt="image-20200724161347135"></p>
<p>注意我在图中画的 <strong>ClusterRoleBinding</strong> 的位置，之前在介绍 Binding 概念的时候就提到一句话：<strong>Kubernetes 中权限控制的范围（Namespace/Cluster）是由 Binding 的类型决定的，而不是根据 Role 和 ClusterRole 决定的</strong>。想要实现作用于集群范围的 RBAC，一定是通过 ClusterRoleBinding，并且要注意的是，通过 ClusterRoleBinding 方式进行绑定时，只允许绑定到 ClusterRole 角色，可以简单理解为全局方法只能去用 ClusterRole 这种全局量。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: ClusterRoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: cluster-admin-biding
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: ClusterRole
  <span style="color:#66d9ef">name</span>: cluster-admin
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h2 id="总结">总结</h2>
<p>关于 Kubernetes RBAC 机制的学习，首先要从基本的 RBAC 概念出发，理解 RBAC 这种权限管理机制的本质思想，即<strong>主体-角色-权限</strong>三者的关系，在此基础上，针对 Kubernetes 对于 RBAC 的实现进行理解学习，核心是要理解 Role 和 ClusterRole 的本质概念与作用，比如为什么在复用角色时要使用 ClusterRole。然后，深刻理解 RoleBinding 和 ClusterRoleBinding 的区别，要记住，Kubernetes RBAC 中对于权限控制的范围不是由 Role 决定的，而是由 Binding 的类型决定的。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.xiaoman.cn/detail/150">https://www.xiaoman.cn/detail/150</a></li>
<li><a href="https://www.cnblogs.com/panwenbin-logs/p/10046572.html">https://www.cnblogs.com/panwenbin-logs/p/10046572.html</a></li>
<li><a href="https://blog.51cto.com/wzlinux/2334119">https://blog.51cto.com/wzlinux/2334119</a></li>
<li><a href="https://www.cnblogs.com/peng-zone/p/11689017.html">https://www.cnblogs.com/peng-zone/p/11689017.html</a></li>
</ul></div>
        <div class="post-footer">
            <div class="info">
                
                <span class="separator"><a class="tag" href="/tags/kubernetes/">kubernetes</a></span>

            </div>
        </div>

        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="https://blog.yingchi.io/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js"
        integrity="sha256-hrHo&#43;BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw="
        crossorigin="anonymous"></script>




<script type="text/javascript"
        src="https://blog.yingchi.io/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js"
        integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4="
        crossorigin="anonymous"></script>

<script type="text/javascript"
        src="https://blog.yingchi.io/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js"
        integrity="sha256-kvIchWEp&#43;ErrcZRZs&#43;asYhowMv17GAoYwE4dEgg/iro="
        crossorigin="anonymous"></script>
</body>

</html>
