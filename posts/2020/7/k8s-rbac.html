<!doctype html>
<html lang="en">
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

  <title>一文读懂 Kubernetes RBAC 机制 - Yingchi Blog</title>
  <meta content='一文读懂 Kubernetes RBAC 机制 - Yingchi Blog' property='title' />
  <meta content='一文读懂 Kubernetes RBAC 机制 - Yingchi Blog' property='og:title' />


<meta property="og:description" content="之前在做 PaaS 平台开发时涉及到租户的权限管理，考虑到 Kubernetes 默认提供了 RBAC（基于角色的访问控制）机制，于是想如何利用好 Kubernetes 的 RBAC 来实现。但是开始学习这块儿知识的时候还是遇到了一些问题，比如 Role 和 ClusterRole，Role Binding 和 ClusterRoleBinding，很多概念是比较模糊的，随着后来深入的学习了解和实践才算理清它们之间的关系，这篇文章就是分享一下这期间学到的内容。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.yingchi.io/posts/2020/7/k8s-rbac.html" />


<meta property="article:published_time" content="2020-07-23T21:15:06&#43;08:00"/>

<meta property="article:modified_time" content="2020-07-23T21:15:06&#43;08:00"/>

<meta property="og:site_name" content="Yingchi&#39;s Blog" />







<meta name="generator" content="Hugo 0.71.1" />

<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" rel="stylesheet">
<style type="text/css">/*https://coolors.co/afd5aa-f0f2ef-a69f98-3d3d3d-8c6057*/
:root {
  --main-color: #8C6056; 
  --secondary-color: #AFD5AA;
  --logo-text-color: #fff;
  --body-text-color: #3d3d3d;
  --heading-text-color: #383838;
  --background-color: #fff;
}</style>
<link href='/css/tachyons.min.css' rel="stylesheet">
<link href='/css/styles.css' rel="stylesheet">


<link rel="icon" 

  href="/favicons/" 

type="image/x-icon"/>

<link href='/feed.xml' rel="alternate" type="application/atom+xml" title="Yingchi Blog" />
</head>
<body class="global-font">
  <nav class=" flex-ns justify-between border-box pa3 pl3-l pr2-l mt1 mt0-ns" id="navbar">
  <div class="flex">
    <a class="f4 fw6 ttu no-underline dim bg-main-color pv1 ph2 br2" id="site-title" href='/' title="Home">Yingchi Blog</a>
  </div>
  
  <div class=" flex-ns mt2 mt0-ns pv1">
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/' title="Home">Home</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/posts.html' title="Posts">Posts</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/tags.html' title="Tags">Tags</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/about.html' title="About">About</a>
    
  </div>
  
</nav>
  
<main class="center mv4 content-width ph3">
  <div class="f3 fw6 heading-color heading-font post-title">一文读懂 Kubernetes RBAC 机制</div>
  <p class="silver f6 mt1 mb4 post-meta">
    <time>23 Jul 2020</time> 
     | 
    
    
    tags: [ <a href='/tags/kubernetes' class="link silver">kubernetes</a>  ]
    
  </p>
  <div class="lh-copy post-content"><p>之前在做 PaaS 平台开发时涉及到租户的权限管理，考虑到 Kubernetes 默认提供了 RBAC（基于角色的访问控制）机制，于是想如何利用好 Kubernetes 的 RBAC 来实现。但是开始学习这块儿知识的时候还是遇到了一些问题，比如 Role 和 ClusterRole，Role Binding 和 ClusterRoleBinding，很多概念是比较模糊的，随着后来深入的学习了解和实践才算理清它们之间的关系，这篇文章就是分享一下这期间学到的内容。</p>
<h2 id="什么是-rbac">什么是 RBAC？</h2>
<h3 id="rbac基于角色的访问控制">RBAC（基于角色的访问控制）</h3>
<p>RBAC，Role-Based Access Control，即<strong>基于角色的访问控制</strong>，通过自定义具有某些特定 Permission 的 Role，然后将 Role 和特定的 Subject（user，group，serviceaccounts&hellip;)关联起来已达到权限控制的目的。</p>
<p>RBAC 中有三个比较重要的概念：</p>
<ul>
<li><strong>Role</strong>：角色，本质是<strong>一组规则权限的集合</strong>，注意：RBAC 中，Role 只声明授予权限，而不存在否定规则；</li>
<li><strong>Subject</strong>：被作用者，包括 <strong>user</strong>，<strong>group</strong>，通俗来讲就是<strong>认证机制中所识别的用户</strong>；</li>
<li><strong>RoleBinding</strong>：定义了“<strong>Role</strong>”和“<strong>Subject</strong>”的绑定关系，也就是将用户以及操作权限进行绑定；</li>
</ul>
<p>RBAC 其实就是通过创建角色(Role），通过 RoleBinding 将被作用者（subject）和角色（Role）进行绑定。下图是 RBAC 中的几种绑定关系：</p>
<p><img src="k8s-rbac/image-20200724134525120.png" alt="image-20200724134525120"></p>
<h2 id="kubernetes-rbac">Kubernetes RBAC</h2>
<p>现在以 Kubernetes 的视角重新来看 RBAC 的实现。</p>
<p>Kubernetes 中实现 RBAC 角色创建、角色绑定整个流程还是比较清晰的，RBAC 的配置都是以资源配置的形式呈现给管理员，我们只需要定义一些配置文件即可，当然在这其中会涉及到对一些配置的理解。首先来看 Kubernetes 中 RBAC 配置关系图：</p>
<p><img src="k8s-rbac/image-20200724142728798.png" alt="image-20200724142728798"></p>
<p>如图可知，实现 Kubernetes 的自定义 RBAC 过程，主要涉及到几个概念，其实一开始已经提到过了，这不过在 Kubernetes 中定义了更具体的概念，这是重点需要关注的。</p>
<h3 id="subject">Subject</h3>
<p>主体，kubernetes 中的 Subject 包括了 User、Group、Service Account，前两个好理解，Service Account 其实就是区别开 User Account 的，Kubernetes 中的资源也是可以当做一个 Subject 的，比如一个 Pod 需要操作集群资源时，它采用的就是 Service Account。</p>
<p>Kubernetes 并没有实现对于 User Account 的直接管理，需要管理员自行手动创建 User Account，本文不针对这一块儿展开说明，大家可以查阅相关文章进行学习。</p>
<h3 id="role">Role</h3>
<p>角色，角色本质就是一组规则权限的集合，通过与具体的 Subject 绑定，从而赋予 Subject 相应的一组权限。</p>
<p>在 Kubernetes 中，Role 分为两类：</p>
<ul>
<li>Role：角色，可以理解为 Namespace Role，Role 在定义时要指定 Namespace，即这个 Role 是定义在 Namespace 内部，因此它所定义的规则权限集合也是针对于其定义所在的 Namespace 下的资源。</li>
<li>ClusterRole：集群角色，顾名思义，这种类型的 Role 是定义在整个 Cluster 下的，定义 Cluster Role 时不需要指定具体的 Namespace。</li>
</ul>
<p><strong>Role 示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: Role
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">namespace</span>: ns-a  <span style="color:#75715e"># 定义于 namespace 下</span>
  <span style="color:#66d9ef">name</span>: pod-reader
<span style="color:#66d9ef">rules</span>:
- <span style="color:#66d9ef">apiGroups</span>: [<span style="color:#e6db74">&#34;&#34;</span>]
  <span style="color:#66d9ef">resources</span>: [<span style="color:#e6db74">&#34;pods&#34;</span>]
  <span style="color:#66d9ef">verbs</span>: [<span style="color:#e6db74">&#34;get&#34;</span>, <span style="color:#e6db74">&#34;watch&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span>]
</code></pre></div><p><strong>ClusterRole 示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: ClusterRole
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pod-reader
<span style="color:#66d9ef">rules</span>:
- <span style="color:#66d9ef">apiGroups</span>: [<span style="color:#e6db74">&#34;&#34;</span>]
  <span style="color:#66d9ef">resources</span>: [<span style="color:#e6db74">&#34;pods&#34;</span>]
  <span style="color:#66d9ef">verbs</span>: [<span style="color:#e6db74">&#34;get&#34;</span>, <span style="color:#e6db74">&#34;watch&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span>]
</code></pre></div><p>注意：ClusterRole 并不代表权限控制的范围是整个 Cluster，还与之后要讲的 Binding 类型有关系，这里的 ClusterRole 应该理解为一种全局量，可以作用于某个 Namespace 下（起到复用的作用），可以作用于 Cluster 范围下。</p>
<p>每个 Role 在定义时关键的一步要指定该 Role 所具有的 rules，Kubernetes 中权限规则需要指定以下几点：</p>
<ul>
<li>apiGroups：资源组，<code>&quot;&quot;</code> 缺省为 core 组资源，其它诸如 apps 等；</li>
<li>resources：资源，比如 pods、deployments、services、secrets 等；</li>
<li>verbs：操作动词，如 get、list、watch、create、delete、update 等。</li>
</ul>
<h3 id="binding">Binding</h3>
<p>绑定，单从概念上很好理解，就是把定义好规则权限的 Role 绑定到指定的 Subject 上，从而赋予 Subject 相应的一系列权限。</p>
<p>kubernetes 中 Binding 分为两种：</p>
<ul>
<li>RoleBinding：绑定 Role/ClusterRole 到 Subject，生效于具体的 Namespace 范围资源；</li>
<li>ClusterRoleBinding：绑定 ClusterRole 到 Subject，生效于 Cluster 范围资源；</li>
</ul>
<p>再次强调：</p>
<p><strong>Kubernetes 中权限控制的范围（Namespace/Cluster）是由 Binding 的类型决定的，而不是根据 Role 和 ClusterRole 决定的，这一点一定要记住</strong>。</p>
<h3 id="作用于-namespace-范围的-rbac-方案分析">作用于 Namespace 范围的 RBAC 方案分析</h3>
<h4 id="方法1role--rolebinding-的组合">方法1：Role + RoleBinding 的组合</h4>
<p><img src="k8s-rbac/image-20200724152635068.png" alt="image-20200724152635068"></p>
<p>如上图，这种方式是比较直观的，因为之前说过 Kubernetes 中的 Role 应该理解为 Namespace Role，它是定义在 Namespace 下面的，因此如果要实现 Namespace 范围内的 Subject 与 Role 的绑定，无非就是通过配置一个 RoleBinding 把两者联系起来。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: RoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pods-reader-binding
  <span style="color:#66d9ef">namespace</span>: ns-a
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: Role
  <span style="color:#66d9ef">name</span>: pod-reader
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h4 id="方法2clusterrole--rolebinding-的组合推荐">方法2：ClusterRole + RoleBinding 的组合（推荐）</h4>
<p><img src="k8s-rbac/image-20200724153218582.png" alt="image-20200724153218582"></p>
<p>一听 ClusterRole，很多朋友会潜意识认为是关于集群范围下的权限控制，但是实际上，权限控制的范围和 Role 的类型没有直接的关系，ClusterRole，它的本质是一个定义在全局的角色，可以作用于 Namespace 下，可以被多个 Namespace 复用，也可以作用于 Cluster 下。</p>
<p>我们现在需要实现 Namespace 范围内绑定 Subject &amp; Role，就是将 ClusterRole 的权限范围控制在 Namespace 层面，因此采用 RoleBinding 将 Subject 与 ClusterRole 即可实现。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: RoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: pods-reader-binding
  <span style="color:#66d9ef">namespace</span>: ns-a
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: ClusterRole
  <span style="color:#66d9ef">name</span>: pod-reader
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h4 id="方法分析">方法分析</h4>
<p>为什么会推荐使用 ClusterRole + RoleBinding 的组合呢？</p>
<p>思考一个问题，假如设计一个 PodReader Role，作用就是有 get/list/watch 当前 Namespace 下 Pod 的权限，如果两个 namespace 都需要这么一个 Role，那么应该怎么设计呢？</p>
<p>采用上面讲的第一种方法的话，每个 namespace 需要定义一个 PodReader 的 Role：</p>
<p><img src="k8s-rbac/image-20200724160240848.png" alt="image-20200724160240848"></p>
<p>这样做有个很明显的缺点，PodReader 的规则权限其实在每个 Namespace 下都是一样的，但是由于 Role 的限制，必须在每个 Namespace 下单独定义，资源浪费，过程也不优雅，如何去复用 PodReader 这个 Role 呢？于是，才有了第二种方法：</p>
<p><img src="k8s-rbac/image-20200724160150128.png" alt="image-20200724160150128"></p>
<p>如图，也就是将 PodReader 定义为 ClusterRole，然后通过 RoleBinding 在不同 Namespace 下绑定不同的 Subject 到同一个 ClusterRole。</p>
<h4 id="小结">小结</h4>
<p>如果自定义的 Role 在很多个 Namespace 中都会用到，那么推荐采用 ClusterRole + RoleBinding 的组合，实现 Role 的复用，如果真的是某个 Namespace 必须要单独定义的私有 Role，再去用 Role + RoleBinding 的组合，但是这样的话 Role 就会比较局限。</p>
<h3 id="作用于集群范围的-rbac-方案分析">作用于集群范围的 RBAC 方案分析</h3>
<p>方案只有一个，就是通过 <strong>ClusterRoleBinding + ClusterRole</strong>：</p>
<p><img src="k8s-rbac/image-20200724161347135.png" alt="image-20200724161347135"></p>
<p>注意我在图中画的 <strong>ClusterRoleBinding</strong> 的位置，之前在介绍 Binding 概念的时候就提到一句话：<strong>Kubernetes 中权限控制的范围（Namespace/Cluster）是由 Binding 的类型决定的，而不是根据 Role 和 ClusterRole 决定的</strong>。想要实现作用于集群范围的 RBAC，一定是通过 ClusterRoleBinding，并且要注意的是，通过 ClusterRoleBinding 方式进行绑定时，只允许绑定到 ClusterRole 角色，可以简单理解为全局方法只能去用 ClusterRole 这种全局量。</p>
<p><strong>配置示例</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">kind</span>: ClusterRoleBinding
<span style="color:#66d9ef">apiVersion</span>: rbac.authorization.k8s.io/v1
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: cluster-admin-biding
<span style="color:#66d9ef">subjects</span>:
- <span style="color:#66d9ef">kind</span>: User
  <span style="color:#66d9ef">name</span>: yingchi
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
<span style="color:#66d9ef">roleRef</span>:
  <span style="color:#66d9ef">kind</span>: ClusterRole
  <span style="color:#66d9ef">name</span>: cluster-admin
  <span style="color:#66d9ef">apiGroup</span>: rbac.authorization.k8s.io
</code></pre></div><h2 id="总结">总结</h2>
<p>关于 Kubernetes RBAC 机制的学习，首先要从基本的 RBAC 概念出发，理解 RBAC 这种权限管理机制的本质思想，即<strong>主体-角色-权限</strong>三者的关系，在此基础上，针对 Kubernetes 对于 RBAC 的实现进行理解学习，核心是要理解 Role 和 ClusterRole 的本质概念与作用，比如为什么在复用角色时要使用 ClusterRole。然后，深刻理解 RoleBinding 和 ClusterRoleBinding 的区别，要记住，Kubernetes RBAC 中对于权限控制的范围不是由 Role 决定的，而是由 Binding 的类型决定的。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.xiaoman.cn/detail/150">https://www.xiaoman.cn/detail/150</a></li>
<li><a href="https://www.cnblogs.com/panwenbin-logs/p/10046572.html">https://www.cnblogs.com/panwenbin-logs/p/10046572.html</a></li>
<li><a href="https://blog.51cto.com/wzlinux/2334119">https://blog.51cto.com/wzlinux/2334119</a></li>
<li><a href="https://www.cnblogs.com/peng-zone/p/11689017.html">https://www.cnblogs.com/peng-zone/p/11689017.html</a></li>
</ul></div>
</main>
 






<div class="tl fixed list-pages lh-copy" id="contents-list"></div>



<div class="pagination tc tr-l db fixed-l bottom-2-l right-2-l mb3 mb0-l">
  
<a id="scroll-to-top" class="f6 o-0 link br2 ph2 pv1 mb1 bg-main-color pointer" onclick="topFunction()" style="color: #fff; visibility: hidden; display: none; transition: opacity .5s, visibility .5s;" title="back to top">back to top</a>
<br>
  <p class="mb0 mt2">
  <a href="https://blog.yingchi.io/posts/2020/7/k8s-authn-authz.html">prev post</a>
  <a href="https://blog.yingchi.io/posts/2020/7/k8s-cm-informer.html">next post</a>
  </p>
</div>

  <footer class="content-width mt0 mt5-l mb4 f6 center ph3 gray tc tl-l">
  <hr class="dn db-l ml0-l gray w3"><br>
  Powered by <a href="https://gohugo.io/" target="_blank" class="link gray dim">Hugo</a>, based on the <a href="https://github.com/lingxz/er" target="_blank" class="link gray dim">Er</a> theme. <br>
  © 2021 Joey.Jiang
</footer>
  



<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<style>.is-active-link::before { background-color: var(--secondary-color); }</style>




<script type="text/javascript">
var prevScrollpos = window.pageYOffset;
window.onscroll = function() {
  var currentScrollPos = window.pageYOffset;

  
  if (document.getElementById("tag-cloud") !== null) { 
    if (prevScrollpos > currentScrollPos) { 
      document.getElementById("tag-cloud").style.visibility = "visible";
      document.getElementById("tag-cloud").style.opacity = "1";
    } else {
      document.getElementById("tag-cloud").style.visibility = "hidden";
      document.getElementById("tag-cloud").style.opacity = "0";
    }
  }
  

  
  if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
      document.getElementById("scroll-to-top").style.display = "inline";
      document.getElementById("scroll-to-top").style.visibility = "visible";
      document.getElementById("scroll-to-top").style.opacity = "1";
  } else {
      document.getElementById("scroll-to-top").style.visibility = "hidden";
      document.getElementById("scroll-to-top").style.opacity = "0";
  }
  
  prevScrollpos = currentScrollPos;
}


function topFunction() {
  document.body.scrollTop = 0; 
  document.documentElement.scrollTop = 0; 
}






if (document.getElementById("contents-list") !== null && document.getElementsByClassName("post-content").length !== 0) { 
  tocbot.init({
    
    tocSelector: '#contents-list',
    
    contentSelector: '.post-content',
    
    headingSelector: 'h1, h2, h3',
  });
}


</script>




</body>
</html>