<!DOCTYPE html>
<html lang="en" data-theme=""><head>
    <title> Joey Jiang </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.71.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Infrastructure SRE / Golang / Python">
    
    <link rel="stylesheet"
          href="https://blog.yingchi.io/css/style.min.6e0d9ffda91065e50deabfa54622d049fd42d3343eca4ed01eb515705f5dd317.css"
          integrity="sha256-bg2f/akQZeUN6r&#43;lRiLQSf1C0zQ&#43;yk7QHrUVcF9d0xc="
          crossorigin="anonymous"
          type="text/css">
    
    <link rel="stylesheet"
        href="https://blog.yingchi.io/css/markupHighlight.min.9755453ffb7bc4cd220f86ebb5922107b49f193cc62fc17e9785d27b33a8bf5b.css"
        integrity="sha256-l1VFP/t7xM0iD4brtZIhB7SfGTzGL8F&#43;l4XSezOov1s="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="https://blog.yingchi.io/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://blog.yingchi.io/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://blog.yingchi.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://blog.yingchi.io/favicons/favicon-16x16.png">

    <link rel="canonical" href="https://blog.yingchi.io/">

    
    <link rel="alternate" type="application/rss+xml" href="https://blog.yingchi.io/index.xml" title="Yingchi Blog" />
    
    
    
    <script type="text/javascript"
            src="https://blog.yingchi.io/js/anatole-header.min.d8599ee07b7d3f11bafbac30657ccc591e8d7fd36a9f580cd4c09e24e0e4a971.js"
            integrity="sha256-2Fme4Ht9PxG6&#43;6wwZXzMWR6Nf9Nqn1gM1MCeJODkqXE="
            crossorigin="anonymous"></script>


    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.yingchi.io/images/site-feature-image.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Infrastructure SRE / Golang / Python"/>

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="https://blog.yingchi.io/images/profile.jpg" alt="profile picture">
            <h2 title=""><a href="/">Yingchi&#39;s Blog</a></h2>
            <div class="description">
                <p>Infrastructure SRE / Golang / Python</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://yingchi.io" rel="me" aria-label="Home">
                    <i class="fa fa-home" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/yingchi1994" rel="me" aria-label="GitHub">
                    <i class="fab fa-github" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:yingchi1994@gmail.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope" style="font-size:large;" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    
    <div class="tag-area">
        
<ul>
  <li class="tag-list">
    
    <a href="/tags/cloud-native.html">
      <span>
        <span class="tag-yingchi">
          Cloud Native
          [<span>1</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/docker.html">
      <span>
        <span class="tag-yingchi">
          Docker
          [<span>2</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/golang.html">
      <span>
        <span class="tag-yingchi">
          Golang
          [<span>5</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/istio.html">
      <span>
        <span class="tag-yingchi">
          Istio
          [<span>2</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/kubernetes.html">
      <span>
        <span class="tag-yingchi">
          Kubernetes
          [<span>15</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/network.html">
      <span>
        <span class="tag-yingchi">
          Network
          [<span>4</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/note.html">
      <span>
        <span class="tag-yingchi">
          Note
          [<span>1</span>]
        </span>
      </span>
    </a>
  </li>
  <li class="tag-list">
    
    <a href="/tags/service-mesh.html">
      <span>
        <span class="tag-yingchi">
          Service Mesh
          [<span>2</span>]
        </span>
      </span>
    </a>
  </li>
</ul>

</div>


    <div class="footer">
        <div class="by_farbox">&copy; Joey Jiang  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <div class="mobile-logo"><a href="/">Yingchi's Blog</a></div>
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a class="current"
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/posts.html"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/tags.html"
                        
                   title="">Tags</a></li>
        
            
            <li><a 
                   href="/about.html"
                        
                   title="">About</a></li>
        
        
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">

    <div class="post  animated fadeInDown ">
        
        <!-- raw HTML omitted -->
<!-- raw HTML omitted -->

    </div>

    
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/8/go-context.html">理解 Golang Context 机制</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p><p>在使用 Golang 的一些框架的时候，比如 Gin，每一个请求的 Handler 方法总是需要传递进去一个 <strong>context</strong> 对象，然后很多请求数据，比如请求参数，路径变量等都可以从中读出来，其实在这个使用过程中已经大体理解了这个 context 是个什么东西，但是对于其中的一些细节包括具体的使用方式还是缺乏了解，因此本文就针对 golang 里面的 context 概念进行简单的探讨。</p></p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Sat, Aug 15, 2020</span>
                        <a class="tag-yingchi" href="/tags/golang/">golang
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/8/k8s-flannel.html">循序渐进理解CNI机制与Flannel工作原理</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p><p>CNI，它的全称是 Container Network Interface，即容器网络的 API 接口。kubernetes 网络的发展方向是希望通过插件的方式来集成不同的网络方案， CNI 就是这一努力的结果。CNI 只专注解决容器网络连接和容器销毁时的资源释放，提供一套框架，所以 CNI 可以支持大量不同的网络模式，并且容易实现。</p></p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Wed, Aug 12, 2020</span>
                        <a class="tag-yingchi" href="/tags/kubernetes/">kubernetes
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/7/k8s-cm-informer.html">解读 kubernetes Controller Manager 工作原理</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p><p>kubernetes master 节点最重要的三个组件是：kube-apiserver、kube-controller-manager、kube-scheduler，分别负责 kubernetes 集群的资源访问入口、集群状态管理、资源调度。</p>
<p>这篇文章的主角就是其中的 kube-controller-manager 组件，分析一下它以及其核心组件 informer 是如何有效管理集群状态的。</p></p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Fri, Jul 24, 2020</span>
                        <a class="tag-yingchi" href="/tags/kubernetes/">kubernetes
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/7/k8s-rbac.html">一文读懂 Kubernetes RBAC 机制</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p><p>之前在做 PaaS 平台开发时涉及到租户的权限管理，考虑到 Kubernetes 默认提供了 RBAC（基于角色的访问控制）机制，于是想如何利用好 Kubernetes 的 RBAC 来实现。但是开始学习这块儿知识的时候还是遇到了一些问题，比如 Role 和 ClusterRole，Role Binding 和 ClusterRoleBinding，很多概念是比较模糊的，随着后来深入的学习了解和实践才算理清它们之间的关系，这篇文章就是分享一下这期间学到的内容。</p></p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Thu, Jul 23, 2020</span>
                        <a class="tag-yingchi" href="/tags/kubernetes/">kubernetes
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/7/k8s-authn-authz.html">Kubernetes API Server 认证与授权机制</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p><p>kube-apiserver 是 kubernetes 的网关性质的组件，是 kubernetes 集群资源操作的唯一入口，因此像认证与授权等一些过程很明显是要基于这个组件实施。kubernetes 集群的所有操作基本上都是通过 apiserver 这个组件进行的，它提供 HTTP RESTful 形式的 API 供集群内外客户端调用。kubernetes 对于访问 API 来说提供了三个步骤的安全措施：认证、授权、准入控制，当用户使用 kubectl，client-go 或者 REST API 请求 apiserver 时，都要经过这三个步骤的校验。</p></p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Sun, Jul 19, 2020</span>
                        <a class="tag-yingchi" href="/tags/kubernetes/">kubernetes
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/6/cka-note.html">2020 年 6 月 CKA 认证通过分享</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p>CKA (Certified Kubernetes Administrator)认证是由 CNCF 与 Linux Foundation 管理的与 Kubernetes 运维技能相关的一个认证，目前业内对于云原生这一块儿专门的认证还是比较少的。自己目前所做的大部分工作都与 Kubernetes 关系比较密切，因此就报名预约了 6 月份的认证，好好准备一段时间，最后成功通过了认证（证书详见文末）
 考试大纲 CNCF 官网中找到 CKA 认证考试页面 https://www.cncf.io/certification/cka/ 可以看到基本的考试大纲，分值分配情况。
The online exam consists of a set of performance-based items (problems) to be solved in a command line and candidates have 3 hours to complete the tasks.
The Certification focuses on the skills required to be a successful Kubernetes Administrator in industry today. This includes these general domains and their weights on the exam:</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Mon, Jun 29, 2020</span>
                        <a class="tag-yingchi" href="/tags/kubernetes/">kubernetes
                                </a><a class="tag-yingchi" href="/tags/note/">note
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/6/concurrent-pattern.html">浅析并发模型：共享内存/Actor/CSP</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p>Golang 编程中，涉及到并发问题时，通常有以下两种解决方案：
 采用共享内存模型，利用 sync.Mutex / sync.RWMutex 等加锁、设置临界区解决数据并发访问问题； 采用消息通信模型，利用 channel 进行 goroutine 间通信，避开内存共享来解决。  官方推荐大家采用第二种方案，那么它究竟好在哪里呢？
共享内存模型 所谓共享内存模型，就是我们在并发编程的时候，通过让多个并发执行实体（线程/Go程/协程/&hellip;）去操作同一个共享变量，从而达到通信的目的。
比如下面这个 Go 程序例子，全局变量 count 初始值 10000，然后开启 10000 个 Goroutine 去分别执行一次取 count 并 -1 的操作。
package main import ( &#34;fmt&#34; &#34;sync&#34; ) var ( count = 10000 wg sync.WaitGroup ) func buy() { defer wg.Done() countReplica := count count = countReplica - 1 } func main() { for i := 0; i &lt; 10000; i++ { wg.</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Thu, Jun 25, 2020</span>
                        <a class="tag-yingchi" href="/tags/golang/">golang
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/6/istio-sidecar-proxy.html">Istio Sidecar 流量拦截机制分析</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p>流量流经主机的基本过程 过程如下：
 Inbound 流量经过 NIC（网卡）进入主机的网络协议栈； 协议栈会根据预先定制的网络规则(iptables/netfilter)对报文进行检查； 协议栈规则检查后，符合要求的 Inbound 流量会从内核空间进入到用户空间，并进入指定监听端口的进程； 处于用户态的用户进程接收到网络流量报文进行处理后，将处理后的结果再通过用户空间返回给内核空间的网络协议栈； 网络协议栈检查报文，并将结果报文根据指定的网络策略通过网卡发送出去；  Sidecar 流量拦截基本过程 之前的文章已经介绍过了 Sidecar 的注入机制，注入到 Pod 中的即下面两个容器：
 istio-init：InitContainer，用于在 Pod 初始化过程中对 Pod 的 iptables 进行初始配置； istio-proxy：负责与 pilot 组件通信以及流量的控制；该容器运行时会启动两个关键的进程 pilot-agent 和 envoy。pilot-agent 进程会定时跟 istio 的 pilot 组件进行通信，envoy 进程会接收入口和出口网络流量。  注意：istio-proxy 和 Kubernetes 中的 kube-proxy 都是通过 iptables/netfilter 来处理网络流量。只不过 istio-proxy 位于 pod 网络空间，处理的是 pod 内的网络流量，而 kube-proxy 位于宿主机网络空间，处理的是宿主机内网络流量（因为 kube-proxy 是 daemonset，因此它位于 k8s 集群的每个 node 节点上）。
Sidecar 流量拦截其实指基于 iptables 规则，由 init 容器在 Pod 启动的时候首先设置iptables 规则。</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Mon, Jun 22, 2020</span>
                        <a class="tag-yingchi" href="/tags/service-mesh/">service-mesh
                                </a><a class="tag-yingchi" href="/tags/istio/">istio
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/6/istio-sidecar-injection.html">Istio Sidecar 注入机制</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p>Service Mesh 及 Sidecar 概念 在了解 Sidecar 的注入机制前还是先要明确是什么和为什么的问题。
首先，Service Mesh 是什么？
Service Mesh，或者翻译为「服务网格」，是一个可配置的低延迟的基础设施层，目的是通过API（应用程序编程接口）处理应用程序服务之间的大量基于网络的进程间通信。服务网络确保容器化的短暂存在的应用程序的基础结构服务之间的通信快速，可靠和安全。网格提供关键功能，包括服务发现，负载平衡，加密，可观察性，可追溯性，身份验证和授权，以及对断路器模式的支持。其实服务网格的目的说的最简单就是「接管和治理应用程序间的通信」，其中有个最为核心的要点就是，通信，基于 Service Mesh 的服务治理就是在服务的通信或者说调用过程中「做手脚」，离开这一点，Service Mesh 毫无意义，当然，这个应用程序似乎也没有意义了。如下图所示，就是典型的 Service Mesh 基础设施层架构。
可以看到分为 Control Plane 和 Data Plane，Control Plane 的主要作用就是治理规则的控制与下发，而 Data Plane 的主要作用就是处理服务实例间的通信过程，实施指定的治理策略。Data Plane 中就可以看到今天的主角，也就是 Sidecar，正如图中标识的，Sidecar 最准确的表述应该是 「Sidecar Proxy」，它的本质是一个代理组件，这个组件会被直接注入到服务实例相同的 Network Namesapce 下，在 Kubernetes 中，就是注入到 Pod 里面，此时 Sidecar 与服务实例共享 Pod Network Namespace，可以通过 iptables 对流经实例的 inbound 和 outbound 流量进行相应的规则处理。
本文主要基于 Istio 这个 Service Mesh 实现针对 Sidecar 的注入机制进行分析。
Admission Controller 与 Admission Webhook Sidecar 的注入依赖于 Kubernetes 的几个概念，其中比较核心的就是 Admission Controller 和 Admission Webhook。</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Sun, Jun 21, 2020</span>
                        <a class="tag-yingchi" href="/tags/service-mesh/">service-mesh
                                </a><a class="tag-yingchi" href="/tags/istio/">istio
                                </a>
                    </div>
                </div>
            </div>
        </div>
    

        <div class="post  animated fadeInDown ">
            <div class="post-title">
                <h3><a href="/posts/2020/5/what-is-cloud-native.html">Cloud Native 云原生 | 概念解读</a>
                </h3>
            </div>
            <div class="post-content">
                <div class="p_part"><p>定义的探索之路 都在提「云原生」的概念，但是真正理解这个概念的又有多少人呢？每次浏览一些社区的时候（不乏一些专业的技术社区），看到有些朋友在讨论云原生相关的话题，有些时候总感觉他们对于云原生的理解还是有那么一点问题。
很多朋友直接就认为部署在云端的应用就叫做云原生应用，一般出现在刚接触云计算与云原生概念的群体中，这个明显是错误的认识，或者说就是「概念滥用」，再有就是懂一些容器化相关概念的内行人士，他们认为，云原生应用是通过容器技术构建，部署在 Kubernetes 这种容器编排平台上的，才能是云原生应用，这听起来像那么回事了，但是呢，还是不够严谨，只是从云原生应用的实现层面来讲的，但是对于其核心概念还是没解释，比如 Cloud Native 的 Native 具体体现在什么上？
其实也不能怪大家伙没搞明白啥是云原生，其实就连最早发起云原生概念的这群人自己也是在逐渐摸索。
来看 CNCF 最初对云原生的定义：
 The CNCF defines “cloud-native” a little more narrowly, to mean using open source software stack to be containerized, where each part of the app is packaged in its own container, dynamically orchestrated so each part is actively scheduled and managed to optimize resource utilization, and microservices-oriented to increase the overall agility and maintainability of applications.</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">Fri, May 29, 2020</span>
                        <a class="tag-yingchi" href="/tags/cloud-native/">cloud-native
                                </a>
                    </div>
                </div>
            </div>
        </div>
    
    <div class="pagination">
        

<ul class="pagination">
    
    <li class="page-item">
        <a href="/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/page/2.html">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/page/3.html">3</a></li>
    
    
    <li class="page-item">
    <a href="/page/2.html" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/page/3.html" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>


    </div>






        </div>
    </div>
</div>

<script type="text/javascript"
        src="https://blog.yingchi.io/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js"
        integrity="sha256-hrHo&#43;BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw="
        crossorigin="anonymous"></script>




<script type="text/javascript"
        src="https://blog.yingchi.io/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js"
        integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4="
        crossorigin="anonymous"></script>

<script type="text/javascript"
        src="https://blog.yingchi.io/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js"
        integrity="sha256-kvIchWEp&#43;ErrcZRZs&#43;asYhowMv17GAoYwE4dEgg/iro="
        crossorigin="anonymous"></script>
</body>

</html>
